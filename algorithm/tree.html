<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>二叉树 | 前端知识总结</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/fe-life/favicon.ico">
    <meta name="description" content="汇总前端知识点">
    
    <link rel="preload" href="/fe-life/assets/css/0.styles.dc91a417.css" as="style"><link rel="preload" href="/fe-life/assets/js/app.006c982a.js" as="script"><link rel="preload" href="/fe-life/assets/js/2.13686704.js" as="script"><link rel="preload" href="/fe-life/assets/js/11.c6d75fa7.js" as="script"><link rel="prefetch" href="/fe-life/assets/js/10.4716d5b4.js"><link rel="prefetch" href="/fe-life/assets/js/12.b51805a3.js"><link rel="prefetch" href="/fe-life/assets/js/13.ef960e6c.js"><link rel="prefetch" href="/fe-life/assets/js/14.3bb9b2de.js"><link rel="prefetch" href="/fe-life/assets/js/15.cad4b3c0.js"><link rel="prefetch" href="/fe-life/assets/js/16.c9264f2c.js"><link rel="prefetch" href="/fe-life/assets/js/17.2faef5a8.js"><link rel="prefetch" href="/fe-life/assets/js/18.733e7306.js"><link rel="prefetch" href="/fe-life/assets/js/19.62d7b287.js"><link rel="prefetch" href="/fe-life/assets/js/20.2b4907f6.js"><link rel="prefetch" href="/fe-life/assets/js/21.5ba23daa.js"><link rel="prefetch" href="/fe-life/assets/js/22.5331761a.js"><link rel="prefetch" href="/fe-life/assets/js/23.caab7f40.js"><link rel="prefetch" href="/fe-life/assets/js/24.dd3756dc.js"><link rel="prefetch" href="/fe-life/assets/js/25.86cc69ac.js"><link rel="prefetch" href="/fe-life/assets/js/3.54f7104d.js"><link rel="prefetch" href="/fe-life/assets/js/4.dc321bd9.js"><link rel="prefetch" href="/fe-life/assets/js/5.391be865.js"><link rel="prefetch" href="/fe-life/assets/js/6.ad7e2c0f.js"><link rel="prefetch" href="/fe-life/assets/js/7.06e27650.js"><link rel="prefetch" href="/fe-life/assets/js/8.feeaf850.js"><link rel="prefetch" href="/fe-life/assets/js/9.e937fa01.js">
    <link rel="stylesheet" href="/fe-life/assets/css/0.styles.dc91a417.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/fe-life/" class="home-link router-link-active"><!----> <span class="site-name">前端知识总结</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fe-life/html/" class="nav-link">
  HTML/CSS
</a></div><div class="nav-item"><a href="/fe-life/js/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/fe-life/vue/" class="nav-link">
  Vue.js
</a></div><div class="nav-item"><a href="/fe-life/ts/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/fe-life/engineering/" class="nav-link">
  工程化
</a></div><div class="nav-item"><a href="/fe-life/code/" class="nav-link">
  代码题
</a></div><div class="nav-item"><a href="/fe-life/exam/" class="nav-link">
  自查题
</a></div><div class="nav-item"><a href="/fe-life/handwrite/" class="nav-link">
  手写题
</a></div><div class="nav-item"><a href="/fe-life/algorithm/" class="nav-link router-link-active">
  算法
</a></div><div class="nav-item"><a href="/fe-life/composite/" class="nav-link">
  综合题
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/fe-life/html/" class="nav-link">
  HTML/CSS
</a></div><div class="nav-item"><a href="/fe-life/js/" class="nav-link">
  JavaScript
</a></div><div class="nav-item"><a href="/fe-life/vue/" class="nav-link">
  Vue.js
</a></div><div class="nav-item"><a href="/fe-life/ts/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/fe-life/engineering/" class="nav-link">
  工程化
</a></div><div class="nav-item"><a href="/fe-life/code/" class="nav-link">
  代码题
</a></div><div class="nav-item"><a href="/fe-life/exam/" class="nav-link">
  自查题
</a></div><div class="nav-item"><a href="/fe-life/handwrite/" class="nav-link">
  手写题
</a></div><div class="nav-item"><a href="/fe-life/algorithm/" class="nav-link router-link-active">
  算法
</a></div><div class="nav-item"><a href="/fe-life/composite/" class="nav-link">
  综合题
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-life/algorithm/" aria-current="page" class="sidebar-link">算法基础</a></li><li><a href="/fe-life/algorithm/tree.html" aria-current="page" class="active sidebar-link">二叉树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fe-life/algorithm/tree.html#二叉树基础" class="sidebar-link">二叉树基础</a></li><li class="sidebar-sub-header"><a href="/fe-life/algorithm/tree.html#二叉树的遍历" class="sidebar-link">二叉树的遍历</a></li></ul></li><li><a href="/fe-life/algorithm/complexity.html" class="sidebar-link">时间/空间复杂度</a></li><li><a href="/fe-life/algorithm/exercise.html" class="sidebar-link">真题练习</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h1> <h2 id="二叉树基础"><a href="#二叉树基础" class="header-anchor">#</a> 二叉树基础</h2> <h3 id="理解树结构"><a href="#理解树结构" class="header-anchor">#</a> 理解树结构</h3> <p>在理解计算机世界的树结构之前，大家不妨回忆一下现实世界中的树有什么特点：一棵树往往只有一个树根，向上生长后，却可以伸展出无数的树枝、树枝上会长出树叶。由树根从泥土中吸收水、无机盐等营养物质，源源不断地输送到树枝与树叶的那一端。</p> <p>数据结构中的树，首先是对现实世界中树的一层简化：把树根抽象为“根结点”，树枝抽象为“边”，树枝的两个端点抽象为“结点”，树叶抽象为“叶子结点”。</p> <p>把这棵抽象后的树颠倒一下，就得到了计算机中的树结构：</p> <p><img src="https://cdn.jsdelivr.net/gh/ArthurWangCN/PictureBed/20210905110841.png" alt=""></p> <p>结合这张图，我们来讲解树的关键特性和重点概念。希望大家可以牢记以下几点：</p> <ul><li><strong>树的层次计算规则</strong>：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。</li> <li><strong>结点和树的“高度”计算规则</strong>：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。</li> <li><strong>“度”的概念</strong>：一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是3。</li> <li><strong>“叶子结点”</strong>：叶子结点就是度为0的结点。在上图中，最后一层的结点的度全部为0，所以这一层的结点都是叶子结点。</li></ul> <h3 id="理解二叉树结构"><a href="#理解二叉树结构" class="header-anchor">#</a> 理解二叉树结构</h3> <p>二叉树是指满足以下要求的树：</p> <ul><li>它可以没有根结点，作为一棵空树存在</li> <li>如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。如下图：</li></ul> <p><img src="https://cdn.jsdelivr.net/gh/ArthurWangCN/PictureBed/20210905110850.png" alt=""></p> <p>注意，二叉树不能被简单定义为每个结点的度都是2的树。普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。对应到图上来看，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的。</p> <h3 id="二叉树的编码实现"><a href="#二叉树的编码实现" class="header-anchor">#</a> 二叉树的编码实现</h3> <p>在 JS 中，二叉树使用对象来定义。它的结构分为三块：</p> <ul><li>数据域</li> <li>左侧子结点（左子树根结点）的引用</li> <li>右侧子结点（右子树根结点）的引用</li></ul> <p>在定义二叉树构造函数时，我们需要把左侧子结点和右侧子结点都预置为空：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 二叉树结点的构造函数</span>
<span class="token keyword">function</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当你需要新建一个二叉树结点时，直接调用构造函数、传入数据域的值就行了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> node  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>如此便能得到一个值为 1 的二叉树结点。</p> <p>以这个结点为根结点，我们可以通过给 <code>left/right</code> 赋值拓展其子树信息，延展出一棵二叉树。因此从更加细化的角度来看，一棵二叉树的形态实际是这样的：</p> <p><img src="https://cdn.jsdelivr.net/gh/ArthurWangCN/PictureBed/20210905110908.png" alt=""></p> <p>现在各位已经掌握了做二叉树面试题所需要的一系列前置知识。接下来我会带大家一起通过写代码的方式，来搞定二叉树系列里最首当其冲、同时相当热门的考点——二叉树的遍历。</p> <h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="header-anchor">#</a> 二叉树的遍历</h2> <h3 id="命题思路解读"><a href="#命题思路解读" class="header-anchor">#</a> 命题思路解读</h3> <p>以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：</p> <ul><li>先序遍历</li> <li>中序遍历</li> <li>后序遍历</li> <li>层次遍历</li></ul> <p>按照实现方式的不同，遍历方式又可以分为以下两种：</p> <ul><li>递归遍历（先、中、后序遍历）</li> <li>迭代遍历（层次遍历）</li></ul> <p>层次遍历的考察相对比较孤立，我们会把它放在后续的真题归纳解读环节来讲。这里我们重点要看的是先、中、后序遍历三兄弟——由于同时纠结了二叉树和“递归”两个大热命题点，又不属于“偏难怪”之流，遍历三兄弟一直是前端算法面试官们的心头好，考察热度经久不衰。</p> <h3 id="递归遍历初相见"><a href="#递归遍历初相见" class="header-anchor">#</a> 递归遍历初相见</h3> <p>编程语言中，函数Func(Type a,……)直接或间接调用函数本身，则该函数称为递归函数。</p> <p>简单来说，当我们看到一个函数反复调用它自己的时候，递归就发生了。“递归”就意味着“反复”，像咱们之前对二叉树的定义，就可以理解为是一个递归式的定义：</p> <ul><li>它可以没有根结点，作为一棵空树存在</li> <li>如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树。</li></ul> <p>这个定义有着这样的内涵：如果我们想要创建一个二叉树结点作为根结点，那么它左侧的子结点和右侧的子结点也都必须符合二叉树结点的定义，这意味着我们要反复地执行“创建一个由数据域、左右子树组成的结点”这个动作，直到数据被分配完为止。</p> <p>对树的遍历，就可以看做是对这三个部分的遍历。这里就引出一个问题：三个部分中，到底先遍历哪个、后遍历哪个呢？我们此处其实可以穷举一下，假如在保证“左子树一定先于右子树遍历”这个前提，那么遍历的可能顺序也不过三种：</p> <ul><li>根结点 -&gt; 左子树 -&gt; 右子树</li> <li>左子树 -&gt; 根结点 -&gt; 右子树</li> <li>左子树 -&gt; 右子树 -&gt; 根结点</li></ul> <p>上述三个遍历顺序，就分别对应了二叉树的先序遍历、中序遍历和后序遍历规则。</p> <p>在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。</p> <p>所谓的“先序”、“中序”和“后序”，“先”、“中”、“后”其实就是指<strong>根结点的遍历时机</strong>。</p> <h3 id="遍历方法图解与编码实现"><a href="#遍历方法图解与编码实现" class="header-anchor">#</a> 遍历方法图解与编码实现</h3> <p><strong>递归函数的编写要点</strong></p> <p>编写一个递归函数之前，大家首先要明确两样东西：</p> <ul><li>递归式</li> <li>递归边界</li></ul> <p>递归式，它指的是你每一次重复的内容是什么。在这里，我们要做先序遍历，那么每一次重复的其实就是 <code>根结点 -&gt; 左子树 -&gt; 右子树</code> 这个旅行路线。</p> <p>递归边界，它指的是你什么时候停下来。</p> <p>在遍历的场景下，当我们发现遍历的目标树为空的时候，就意味着旅途已达终点、需要画上句号了。这个“画句号”的方式，在编码实现里对应着一个 return 语句——这就是二叉树遍历的递归边界。</p> <h4 id="先序遍历"><a href="#先序遍历" class="header-anchor">#</a> 先序遍历</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 所有遍历函数的入参都是树的根结点对象</span>
<span class="token keyword">function</span> <span class="token function">preorder</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 递归边界，root 为空</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> 
    <span class="token punctuation">}</span>
     
    <span class="token comment">// 输出当前遍历的结点值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'当前遍历的结点值是：'</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  
    <span class="token comment">// 递归遍历左子树 </span>
    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>  
    <span class="token comment">// 递归遍历右子树  </span>
    <span class="token function">preorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结果：</p> <div class="language-text extra-class"><pre class="language-text"><code>当前遍历的结点值是： A
当前遍历的结点值是： B
当前遍历的结点值是： D
当前遍历的结点值是： E
当前遍历的结点值是： C
当前遍历的结点值是： F
</code></pre></div><h4 id="中序遍历"><a href="#中序遍历" class="header-anchor">#</a> 中序遍历</h4> <p>理解了先序遍历的过程，中序遍历就不是什么难题。唯一的区别只是把遍历顺序调换了<code>左子树 -&gt; 根结点 -&gt; 右子树</code>：</p> <p>递归边界照旧，唯一发生改变的是递归式里调用递归函数的顺序——左子树的访问会优先于根结点。我们参考先序遍历的分析思路，来写中序遍历的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 所有遍历函数的入参都是树的根结点对象</span>
<span class="token keyword">function</span> <span class="token function">inorder</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 递归边界，root 为空</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> 
    <span class="token punctuation">}</span>
     
    <span class="token comment">// 递归遍历左子树 </span>
    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>  
    <span class="token comment">// 输出当前遍历的结点值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'当前遍历的结点值是：'</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  
    <span class="token comment">// 递归遍历右子树  </span>
    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结果：</p> <div class="language-text extra-class"><pre class="language-text"><code>当前遍历的结点值是： D
当前遍历的结点值是： B
当前遍历的结点值是： E
当前遍历的结点值是： A
当前遍历的结点值是： C
当前遍历的结点值是： F
</code></pre></div><h4 id="后序遍历"><a href="#后序遍历" class="header-anchor">#</a> 后序遍历</h4> <p>在后序遍历中，我们<code>先访问左子树</code>，<code>再访问右子树</code>，<code>最后访问根结点</code>：</p> <p>在编码实现的时候，递归边界照旧，唯一发生改变的仍然是是递归式里调用递归函数的顺序：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">postorder</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 递归边界，root 为空</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> 
    <span class="token punctuation">}</span>
     
    <span class="token comment">// 递归遍历左子树 </span>
    <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>  
    <span class="token comment">// 递归遍历右子树  </span>
    <span class="token function">postorder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token comment">// 输出当前遍历的结点值</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'当前遍历的结点值是：'</span><span class="token punctuation">,</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  
<span class="token punctuation">}</span>
</code></pre></div><p>结果：</p> <div class="language-text extra-class"><pre class="language-text"><code>当前遍历的结点值是： D
当前遍历的结点值是： E
当前遍历的结点值是： B
当前遍历的结点值是： F
当前遍历的结点值是： C
当前遍历的结点值是： A
</code></pre></div><h3 id="结语"><a href="#结语" class="header-anchor">#</a> 结语</h3> <p>对于二叉树的先、中、后序遍历，各位只要掌握了其中一种的思路，就可以举一反三、顺势推导其它三种思路。不过，我个人的建议，仍然是以“默写”的标准来要求自己，面试时不要指望“推导”，而应该有条件反射。这样才可以尽量地提高你做题的效率，为后面真正的难题、综合性题目腾出时间。</p> <p>关于二叉树遍历类题目的讨论，这里只是一个开始。二叉树的先、中、后包括层次遍历的玩法，还有很多很多，我们在后续的真题归纳解读专题、包括末尾的大规模刷题训练中，会带大家认识更多新奇好玩的东西。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/fe-life/algorithm/" class="prev router-link-active">
        算法基础
      </a></span> <span class="next"><a href="/fe-life/algorithm/complexity.html">
        时间/空间复杂度
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/fe-life/assets/js/app.006c982a.js" defer></script><script src="/fe-life/assets/js/2.13686704.js" defer></script><script src="/fe-life/assets/js/11.c6d75fa7.js" defer></script>
  </body>
</html>
